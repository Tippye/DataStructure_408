# 最小生成树(Minimum-Spanning-Tree, MST)

- 最小生成树一定是**带权连通无向图**
- 最小生成树可能有多个，但边的权值只和总是唯一最小的
- 最小生成树的边数 = 顶点数 - 1
- 如果一个连通图本身就是一棵树，则其最小生成树就是它本身
- 只有连通图才有生成树，非连通图只有生成森林

## Prim 算法(普里姆，用结点找MST)

从某一个顶点开始构建生成树，每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止（贪心）

建议看下面视频理解

![q4zcL7](https://cdn.staticaly.com/gh/tippye/PicCloud@master/uPic/2022/11/27/q4zcL7.png)

![6hltfP](https://cdn.staticaly.com/gh/tippye/PicCloud@master/uPic/2022/11/27/6hltfP.png)

- 时间复杂度只与结点个数有关： O(|V|<sup>2</sup>)
- 适用于边稠密图

## Kruskal 算法(克鲁斯卡尔，用边找MST)

每次选择一条权值最小的边，是这条边两头连通（原本就已经连通的不选），直到所有结点都连通

建议看下面视频理解

![qNyfFW](https://cdn.staticaly.com/gh/tippye/PicCloud@master/uPic/2022/11/27/qNyfFW.png)

![MJkfG3](https://cdn.staticaly.com/gh/tippye/PicCloud@master/uPic/2022/11/27/MJkfG3.png)

- 时间复杂度只与边的个数有关： O(|E| log<sub>2</sub>|E|)
- 适用于边稀疏图

[![最小生成树(Kruskal(克鲁斯卡尔)和Prim(普里姆))算法动画演示](https://i1.hdslb.com/bfs/archive/6c26bfa942170348f8c9a3815f7f4787ab6dc6f3.jpg)](https://www.bilibili.com/video/BV1Eb41177d1/?share_source=copy_web&vd_source=d7eeeba989aec17bda8f3bfcbc45dfee&t=126)

# 最短路径

## BFS

适用于无权图

![Y4nqzA](https://cdn.staticaly.com/gh/tippye/PicCloud@master/uPic/2022/11/28/Y4nqzA.png)

代码参考[4.2BFS(最短路径).cpp](./4.2BFS(最短路径).cpp)

思路是在原BFS算法的基础上增加两个数组`d[]`和`path[]`分别记录最短路径长度和前驱结点

![C1wUb5](https://cdn.staticaly.com/gh/tippye/PicCloud@master/uPic/2022/12/06/C1wUb5.png)

## Dijkstra 算法

![WVdnY4](https://cdn.staticaly.com/gh/tippye/PicCloud@master/uPic/2022/12/06/WVdnY4.png)

循环遍历所有结点，找到还没确定最短路径且`dist`最小的顶点<code>V<sub>i</sub></code>,令`final[i]=true`。检查所有邻接自<code>
V<sub>i</sub></code>的顶点，若其`final`值为`false`，则更新`dist`和`path`信息
重复第二步操作直至所有节点的`final`值都为`true`

![Dijkstra](https://cdn.staticaly.com/gh/tippye/PicCloud@master/uPic/2022/12/06/RPReplay_Final1670327397.GIF)

- 时间复杂度：O(|V|<sup>2</sup>)
- Dijkstra不适用于有**负权值**的带权图

## Floyd 算法

求出每一对顶点之间的最短路径

使用动态规划，将问题的求解分为多个阶段

对于 n 个顶点的图 G，求任意一对顶点 Vi -> Vj 之间的最短路径可分为如下几个阶段：

1. 不允许在其他顶点中转，最短路径是`?`
   - ![86GsF0](https://cdn.staticaly.com/gh/tippye/PicCloud@master/uPic/2022/12/09/86GsF0.png)
   - A矩阵可以直接用图的邻接矩阵
2. 若允许在<code>V<sub>0</sub></code>中转，最短路径是`?`
   - ![WIL79q](https://cdn.staticaly.com/gh/tippye/PicCloud@master/uPic/2022/12/09/WIL79q.png)
   - 因为可以在V<sub>0</sub>中转，V<sub>0</sub>到V<sub>1</sub>的距离可以更新
3. 若允许在<code>V<sub>0</sub>、V<sub>1</sub></code>中转，最短路径是`?`
   - ![VTJUmU](https://cdn.staticaly.com/gh/tippye/PicCloud@master/uPic/2022/12/09/VTJUmU.png)
   - 这里可以忽视上边说的V<sub>0</sub>中转，直接用上一步得出的A矩阵就相当于是使用V<sub>0</sub>中转了，所以直接考虑V<sub>
     1</sub>中转
   - 循环后找到V<sub>0</sub>到V<sub>2</sub>会更短，所以更新
4. 若允许在<code>V<sub>0</sub>、V<sub>1</sub>、V<sub>2</sub></code>中转，最短路径是`?`
   - ![sdorct](https://cdn.staticaly.com/gh/tippye/PicCloud@master/uPic/2022/12/09/sdorct.png)
   - 重复前边的步骤一直到最后一个结点即可
5. ···
6. 若允许在<code>V<sub>0</sub>、V<sub>1</sub>、V<sub>2</sub>、...、V<sub>n-1</sub></code>中转，最短路径是`?`

- 时间复杂度: O(|V|<sup>3</sup>)
- 空间复杂度: O(|V|<sup>2</sup>)
- 可以用于有**负权值**的带权图，但是不允许**包含带负权的边组成的回路**（有负权回路的图可能没有最短路径）

## 对比

|         |                                                                  BFS算法                                                                   |          Dijkstra算法          |           Floyd算法            |
|:-------:|:----------------------------------------------------------------------------------------------------------------------------------------:|:----------------------------:|:----------------------------:|
|   无权图   |                                                                    ✔️                                                                    |              ✔️              |              ✔️              |
|   带权图   |                                                                    ❌                                                                     |              ✔️              |              ✔️              |
| 带负权值的图  |                                                                    ❌                                                                     |              ❌               |              ✔️              |
| 带负权回路的图 |                                                                    ❌                                                                     |              ❌               |              ❌️              |
|  时间复杂度  | O(&#124;V&#124;<sup>2</sup>)<font color="grey" size="1">邻接矩阵</font>或O(&#124;V&#124;+&#124;E&#124;)<font color="grey" size="1">邻接表</font> | O(&#124;V&#124;<sup>2</sup>) | O(&#124;V&#124;<sup>3</sup>) |
|  通常用于   |                                                               求无权图的单源最短路径                                                                |         求带权图的单源最短路径          |        求带权图中各顶点间的最短路径        |

# 有向无环图描述表达式

# 拓扑排序

# 关键路径